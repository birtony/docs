# Batch Writer

Orb node will validate each supported Sidetree operation(Create, Update, Recover and Deactivate) 
as per [Sidetree DID Operations](sidetree.html#did-operations) and then add valid operation to the batch writer queue.

Batch writer will:

1) Drain operations from the operations queue (see [Operation Queue](#operation-queue) below).

2) Batch multiple Sidetree operations together into Sidetree batch files 
as per [Sidetree file structure spec](https://identity.foundation/sidetree/spec/#file-structures)

3) Store the Sidetree batch files into content addressable storage (CAS)

4) Anchor a reference to the main Sidetree batch file (core index file) on the anchoring system as a Sidetree transaction

The number of operations that can be stored in the Sidetree batch files is limited  by
Sidetree protocol parameter [MAX_OPERATION_COUNT](https://identity.foundation/sidetree/spec/#:~:text=1%2C000%20bytes-,MAX_OPERATION_COUNT,-Maximum%20number%20of).
The Batch Writer will cut Sidetree batches if the number of operations in the batch writer queue reaches MAX_OPERATION_COUNT
or if the batch writer reaches the batch writer timeout [batch-writer-timeout](parameters.html#batch-writer-timeout).

## Operation Queue

The _Operation Queue_ in Orb is an implementation of the [sidetree-core-go](https://github.com/trustbloc/sidetree-core-go)
operation queue interface. The implemented functions are:

1) **Add**: Adds an operation to the queue
2) **Remove**: Returns and removes up to N operations from the queue
3) **Peek**: Returns (but does not remove) up to N operations from the queue
4) **Len**: Returns the current length of the queue
 
Orb's implementation of the _Operation Queue_ is backed by an AMQP message broker and a database. Each Orb instance
of a domain stores a _task_ entry in the _op-queue_ database on startup. The _task_ entry contains an _ID_ and an
_update time_. The ID is simply the unique ID of the Orb instance (which is a GUID generated by the
[Task Manager](taskmanager.html#task-manager) on startup) and the _update time_ contains the timestamp of when the task
entry was last updated. (This timestamp is used to check the aliveness of the Orb instance.)

### Add Operation

A Sidetree operation is posted by a client to the [operations](sidetree.html#did-operations) REST endpoint (which is
exposed by the [sidetree-core-go](https://github.com/trustbloc/sidetree-core-go) library). After the operation is validated,
the _Add_ function of Orb's _Operation Queue_ is invoked. The _Operation Queue_ then publishes a message containing the operation
to the AMQP _operation_ queue.
Each Orb instance has a pool of subscribers for the operation queue. The number of subscribers in the pool is determined
by startup parameter [op-queue-pool](parameters.html#op-queue-pool). One of the subscribers on an Orb instance handles the
message by adding the operation to the _op-queue_ database and also to an in-memory queue. Operations are stored to the
database for recovery purposes, i.e. if the Orb instance goes down then another instance will repost the operations.
(See [Recovery](#recovery) for details.) Each database entry contains the contents of the operation and is also tagged
(indexed) by:
1) **Task ID**: Associates an operation with a specific _task_ entry (as described above)
2) **Expiration Time**: Tells the [Database Expiry](taskmanager.html#database-expiry) service when this entry may be deleted.
This value is set to (_current time_) + ([batch writer timeout](parameters.html#batch-writer-timeout)) + (1 minute).

```{image} ../_static/orb/op-queue-add.svg

```

### Remove Operations

The [sidetree-core-go](https://github.com/trustbloc/sidetree-core-go) library queries the _Operation Queue_ to see if there are
enough operations to cut a batch (according to the Sidetree protocol parameter
[MAX_OPERATION_COUNT](https://identity.foundation/sidetree/spec/#:~:text=1%2C000%20bytes-,MAX_OPERATION_COUNT,-Maximum%20number%20of),
or if the batch has timed out (according to startup parameter [batch-writer-timeout](parameters.html#batch-writer-timeout)).
When the batch is cut then the sidetree-core-go library calls the _Remove_ function on the _Operation Queue_ to remove up
to N operations from the queue. The _Remove_ function is quasi-transactional such that it returns an _Ack_ and a _Nack_ function
along with the operations.

#### Ack Function

When the [sidetree-core-go](https://github.com/trustbloc/sidetree-core-go) library has successfully processed the operations
then the _Ack_ function is called. The _Ack_ function deletes the removed operations from the _op-queue_ database.

#### Nack Function

If the [sidetree-core-go](https://github.com/trustbloc/sidetree-core-go) library has failed to successfully process the
operations then the _Nack_ function is called. The _Nack_ function reposts the operations to the AMQP _operation_ queue so they
may be retried (potentially by another server instance) and the operations are deleted from the database. Each operation
message that is reposted to the _operation_ queue has a _retries_ header value which is incremented before it is reposted.
Once the maximum number of retries for an operation has been reached, the operation is discarded.

```{image} ../_static/orb/op-queue-cut.svg

```

### Recovery

An Orb server may go down with pending operations in the queue. The _Operation Queue Monitor Task_ is registered with
the [Task Manager](taskmanager.html#task-manager) on startup to periodically run on one server instance in the domain.
The period is specified by startup parameter [op-queue-task-monitor-interval](parameters.html#op-queue-task-monitor-interval).
This task monitors the operation queue tasks of other servers to ensure that if a server goes down then the operations
associated with that server are reposted to the AMQP _operation_ queue.

Each Orb instance periodically (also using the period specified by
[op-queue-task-monitor-interval](parameters.html#op-queue-task-monitor-interval)) updates the _update time_
of its own _task_ entry in the database in order to indicate to other servers that the instance is still alive.

When the monitor task runs, it queries the _op-queue_ database for all _task_ entries (excluding its own) and checks the
_update time_ of the entry. If the update time is older than the expiration time configured with startup parameter
[op-queue-task-expiration](parameters.html#op-queue-task-expiration) then the server that owns the task is considered to
be down. At this point, the _op-queue_ database is queried for the operations associated with the task and each operation
is reposted to the queue. (As described in the [section](#nack-function) above, each operation
message reposted to the _operation_ queue has a _retries_ header value which is incremented before it is reposted.
Once the maximum number of retries for an operation has been reached, the operation is discarded.)
All operations associated with this _task_ are then deleted from the database and the _task_ entry itself is also
deleted from the database. (The _task_ entry is deleted from the database since, when the dead server comes back online,
it will generate a new task ID.)

```{image} ../_static/orb/op-queue-recovery.svg

```

